use eframe::{egui, NativeOptions};
use egui::{
    load::SizedTexture, Color32, RichText, Vec2,
};
use image::GenericImageView;
use lofty::{file::TaggedFileExt, tag::Accessor};
use rfd::FileHandle;
use std::sync::Arc;
use std::time::{Duration, Instant};
use web_audio_api::context::{AudioContext, BaseAudioContext};
use web_audio_api::node::{
    AudioNode, AudioScheduledSourceNode, BiquadFilterNode, BiquadFilterType, AnalyserNode,
};

mod ui;
mod audio_performance;

use ui::{
    theme::{Theme, ThemeManager, ThemeColors},
    layout::{LayoutManager, PanelConfig, PanelType, DockSide},
    spectrum::{SpectrumVisualizer, SpectrumVisualizerConfig, SpectrumMode},
    components::{AlbumArtDisplay, ProgressBar, MetadataDisplay, MetadataLayout, ProgressBarStyle},
    controls::{EnhancedSlider, CircularKnob, EnhancedButton, SliderOrientation, SliderStyle, ButtonStyle},
    utils::{ScreenSize, AnimationState, ResponsiveSize},
};

#[derive(Debug, Clone, PartialEq)]
enum Tab {
    Playback,
    Effects,
    Eq,
    Settings,
}


#[derive(Debug, Clone, PartialEq)]
enum PlaybackState {
    Stopped,
    Playing,
    Paused,
}

#[derive(Debug, Clone)]
struct TrackMetadata {
    title: String,
    artist: String,
    album: String,
    year: String,
}

struct AudioPlayerApp {
    audio_context: AudioContext,
    source_node: Option<web_audio_api::node::AudioBufferSourceNode>,
    gain_node: web_audio_api::node::GainNode,
    playback_state: PlaybackState,
    current_file: Option<Arc<FileHandle>>,
    metadata: Option<TrackMetadata>,
    volume: f32,
    panning: f32,
    is_looping: bool,
    playback_pos: Duration,
    total_duration: Duration,
    is_seeking: bool,
    error: Option<String>,
    album_art: Option<Arc<egui::TextureHandle>>,
    active_tab: Tab,

    // Enhanced UI components
    theme_manager: ThemeManager,
    layout_manager: LayoutManager,
    spectrum_visualizer: SpectrumVisualizer,
    album_art_display: AlbumArtDisplay,
    progress_bar: ProgressBar,
    metadata_display: MetadataDisplay,

    // Enhanced controls
    volume_slider: EnhancedSlider,
    eq_knobs: Vec<CircularKnob>,

    // Audio processing
    spectrum: Vec<f32>,
    eq_bands: Vec<BiquadFilterNode>,
    analyser: AnalyserNode,
    spectrum_processor: audio_performance::SpectrumProcessor,

    // Responsive and animation state
    last_frame_time: Instant,
    screen_size: ScreenSize,
    show_keyboard_shortcuts: bool,
}

impl Default for AudioPlayerApp {
    fn default() -> Self {
        let audio_context = AudioContext::default();
        let analyser = audio_context.create_analyser();
        let gain_node = audio_context.create_gain();
        gain_node.gain().set_value(0.5);

        let mut eq_bands = Vec::new();
        let mut eq_knobs = Vec::new();
        for i in 0..8 {
            let mut band = audio_context.create_biquad_filter();
            band.set_type(BiquadFilterType::Peaking);
            band.frequency().set_value(60.0 * 2.0_f32.powi(i));
            band.q().set_value(1.0);
            band.gain().set_value(0.0);
            eq_bands.push(band);

            // Create corresponding knob control
            eq_knobs.push(CircularKnob::new(0.0, -40.0..=40.0).radius(20.0));
        }

        Self {
            audio_context,
            source_node: None,
            gain_node,
            playback_state: PlaybackState::Stopped,
            current_file: None,
            metadata: None,
            volume: 0.5,
            panning: 0.5,
            is_looping: false,
            playback_pos: Duration::ZERO,
            total_duration: Duration::ZERO,
            is_seeking: false,
            error: None,
            album_art: None,
            active_tab: Tab::Playback,

            // Enhanced UI components
            theme_manager: ThemeManager::new(Theme::Mocha),
            layout_manager: LayoutManager::new(),
            spectrum_visualizer: SpectrumVisualizer::new(SpectrumVisualizerConfig::default()),
            album_art_display: AlbumArtDisplay::new(Vec2::new(200.0, 200.0)),
            progress_bar: ProgressBar::new(),
            metadata_display: MetadataDisplay::new(),

            // Enhanced controls
            volume_slider: EnhancedSlider::new(0.5, 0.0..=1.0)
                .orientation(SliderOrientation::Horizontal)
                .style(SliderStyle::default()),
            eq_knobs,

            // Audio processing
            spectrum: vec![0.0; 1024],
            eq_bands,
            analyser,
            spectrum_processor: audio_performance::SpectrumProcessor::new(2048),

            // Responsive and animation state
            last_frame_time: Instant::now(),
            screen_size: ScreenSize::Desktop,
            show_keyboard_shortcuts: false,
        }
    }
}

impl eframe::App for AudioPlayerApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        // Update responsive layout and timing
        let now = Instant::now();
        let dt = now.duration_since(self.last_frame_time).as_secs_f32();
        self.last_frame_time = now;

        // Update screen size and responsive layout
        let screen_size_vec = ctx.screen_rect().size();
        self.screen_size = ScreenSize::from_width(screen_size_vec.x);
        self.layout_manager.update_responsive_layout(screen_size_vec);

        // Apply theme
        self.theme_manager.apply_theme(ctx);
        let colors = self.theme_manager.get_colors();

        // Update animations
        self.layout_manager.update_animations(dt);

        // Handle keyboard shortcuts
        self.handle_keyboard_input(ctx);

        // Update audio processing
        self.tick();

        // Update UI components
        self.update_ui_components(&colors);

        // Main UI layout using the new layout system
        if self.screen_size == ScreenSize::Mobile {
            self.draw_mobile_layout(ctx, &colors);
        } else {
            self.draw_desktop_layout(ctx, &colors);
        }

        // Show keyboard shortcuts overlay if requested
        if self.show_keyboard_shortcuts {
            self.draw_keyboard_shortcuts_overlay(ctx, &colors);
        }

        // Request repaint for animations
        ctx.request_repaint_after(Duration::from_millis(16)); // ~60 FPS
    }
}

impl AudioPlayerApp {
    fn update_ui_components(&mut self, colors: &ThemeColors) {
        // Update progress bar
        self.progress_bar.set_progress(
            self.playback_pos.as_secs_f32(),
            self.total_duration.as_secs_f32()
        );

        // Update metadata display
        if let Some(metadata) = &self.metadata {
            self.metadata_display.set_metadata(
                metadata.title.clone(),
                metadata.artist.clone(),
                metadata.album.clone(),
                metadata.year.clone(),
            );
        }

        // Update album art display
        self.album_art_display.set_texture(self.album_art.clone());

        // Update spectrum visualizer
        self.spectrum_visualizer.update(&self.spectrum);

        // Update volume slider
        self.volume_slider.set_value(self.volume);
    }

    fn draw_desktop_layout(&mut self, ctx: &egui::Context, colors: &ThemeColors) {
        egui::CentralPanel::default().show(ctx, |ui| {
            ui.horizontal(|ui| {
                ui.heading("ðŸŽµ Rusty Audio");

                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    // Theme selector
                    egui::ComboBox::from_label("")
                        .selected_text(self.theme_manager.current_theme().display_name())
                        .show_ui(ui, |ui| {
                            for theme in Theme::all() {
                                ui.selectable_value(
                                    &mut self.theme_manager,
                                    ThemeManager::new(theme.clone()),
                                    theme.display_name()
                                );
                            }
                        });

                    if ui.button("?").clicked() {
                        self.show_keyboard_shortcuts = !self.show_keyboard_shortcuts;
                    }
                });
            });

            ui.separator();

            // Tab selection
            ui.horizontal(|ui| {
                ui.selectable_value(&mut self.active_tab, Tab::Playback, "ðŸŽµ Playback");
                ui.selectable_value(&mut self.active_tab, Tab::Effects, "ðŸŽ›ï¸ Effects");
                ui.selectable_value(&mut self.active_tab, Tab::Eq, "ðŸ“Š EQ");
                ui.selectable_value(&mut self.active_tab, Tab::Settings, "âš™ï¸ Settings");
            });

            ui.separator();

            match self.active_tab {
                Tab::Playback => self.draw_playback_panel(ui, colors),
                Tab::Effects => self.draw_effects_panel(ui, colors),
                Tab::Eq => self.draw_eq_panel(ui, colors),
                Tab::Settings => self.draw_settings_panel(ui, colors),
            }
        });
    }

    fn draw_mobile_layout(&mut self, ctx: &egui::Context, colors: &ThemeColors) {
        // Mobile layout with bottom tab bar
        egui::TopBottomPanel::bottom("mobile_tabs").show(ctx, |ui| {
            ui.horizontal_centered(|ui| {
                ui.selectable_value(&mut self.active_tab, Tab::Playback, "ðŸŽµ");
                ui.selectable_value(&mut self.active_tab, Tab::Effects, "ðŸŽ›ï¸");
                ui.selectable_value(&mut self.active_tab, Tab::Eq, "ðŸ“Š");
                ui.selectable_value(&mut self.active_tab, Tab::Settings, "âš™ï¸");
            });
        });

        egui::CentralPanel::default().show(ctx, |ui| {
            match self.active_tab {
                Tab::Playback => self.draw_mobile_playback_panel(ui, colors),
                Tab::Effects => self.draw_mobile_effects_panel(ui, colors),
                Tab::Eq => self.draw_mobile_eq_panel(ui, colors),
                Tab::Settings => self.draw_settings_panel(ui, colors),
            }
        });
    }

    fn draw_playback_panel(&mut self, ui: &mut egui::Ui, colors: &ThemeColors) {
        ui.vertical_centered(|ui| {
            ui.add_space(10.0);

            // Album art with enhanced display
            let album_art_response = self.album_art_display.show(ui, colors);

            ui.add_space(10.0);

            // Metadata display
            self.metadata_display.show(ui, colors);

            ui.add_space(15.0);

            // Enhanced progress bar
            let progress_response = self.progress_bar.show(ui, colors);
            if progress_response.changed() {
                self.seek_to_position(self.progress_bar.progress);
            }

            ui.add_space(15.0);

            // Control buttons with enhanced styling
            ui.horizontal_centered(|ui| {
                let mut open_button = EnhancedButton::new("ðŸ“ Open")
                    .style(ButtonStyle {
                        glow: true,
                        ..Default::default()
                    });
                if open_button.show(ui, colors).clicked() {
                    self.open_file();
                }

                ui.add_space(10.0);

                let play_pause_text = if self.playback_state == PlaybackState::Playing { "â¸ï¸ Pause" } else { "â–¶ï¸ Play" };
                let mut play_pause_button = EnhancedButton::new(play_pause_text)
                    .style(ButtonStyle {
                        gradient: true,
                        glow: true,
                        ..Default::default()
                    });
                if play_pause_button.show(ui, colors).clicked() {
                    self.play_pause();
                }

                ui.add_space(10.0);

                let mut stop_button = EnhancedButton::new("â¹ï¸ Stop");
                if stop_button.show(ui, colors).clicked() {
                    self.stop();
                }

                ui.add_space(10.0);

                let loop_text = if self.is_looping { "ðŸ” Loop: On" } else { "ðŸ” Loop: Off" };
                let mut loop_button = EnhancedButton::new(loop_text)
                    .style(ButtonStyle {
                        gradient: self.is_looping,
                        ..Default::default()
                    });
                if loop_button.show(ui, colors).clicked() {
                    self.toggle_loop();
                }
            });

            ui.add_space(20.0);

            // Volume control with enhanced slider
            ui.horizontal_centered(|ui| {
                ui.label("ðŸ”Š Volume:");
                ui.add_space(10.0);
                let volume_response = self.volume_slider.show(ui, colors);
                if volume_response.changed() {
                    self.volume = self.volume_slider.value();
                    self.gain_node.gain().set_value(self.volume);
                }
            });

            // Error display
            if let Some(error) = &self.error {
                ui.add_space(10.0);
                ui.label(RichText::new(error).color(colors.error));
            }
        });
    }

    fn draw_mobile_playback_panel(&mut self, ui: &mut egui::Ui, colors: &ThemeColors) {
        ui.vertical_centered(|ui| {
            // Compact album art
            self.album_art_display.size = Vec2::new(150.0, 150.0);
            self.album_art_display.show(ui, colors);

            ui.add_space(8.0);

            // Compact metadata
            self.metadata_display.layout = MetadataLayout::Compact;
            self.metadata_display.show(ui, colors);

            ui.add_space(10.0);

            // Progress bar
            let progress_response = self.progress_bar.show(ui, colors);
            if progress_response.changed() {
                self.seek_to_position(self.progress_bar.progress);
            }

            ui.add_space(10.0);

            // Compact controls
            ui.horizontal_centered(|ui| {
                if ui.button("ðŸ“").clicked() { self.open_file(); }
                ui.add_space(15.0);

                let play_pause_icon = if self.playback_state == PlaybackState::Playing { "â¸ï¸" } else { "â–¶ï¸" };
                if ui.button(play_pause_icon).clicked() { self.play_pause(); }
                ui.add_space(15.0);

                if ui.button("â¹ï¸").clicked() { self.stop(); }
                ui.add_space(15.0);

                let loop_icon = if self.is_looping { "ðŸ”" } else { "ðŸ”" };
                if ui.button(loop_icon).clicked() { self.toggle_loop(); }
            });

            ui.add_space(10.0);

            // Compact volume
            ui.horizontal_centered(|ui| {
                ui.label("ðŸ”Š");
                let volume_response = self.volume_slider.show(ui, colors);
                if volume_response.changed() {
                    self.volume = self.volume_slider.value();
                    self.gain_node.gain().set_value(self.volume);
                }
            });
        });
    }

    fn draw_effects_tab(&mut self, ui: &mut egui::Ui) {
        ui.label("Spectrum");
        let (rect, _) = ui.allocate_exact_size(Vec2::new(ui.available_width(), 200.0), egui::Sense::hover());
        let painter = ui.painter();
        let color = Color32::from_rgb(0, 128, 255);
        let num_points = self.spectrum.len();
        let point_spacing = rect.width() / num_points as f32;

        let mut points = Vec::with_capacity(num_points);
        for (i, val) in self.spectrum.iter().enumerate() {
            let x = rect.min.x + i as f32 * point_spacing;
            let y = rect.center().y - val * rect.height() / 2.0;
            points.push(egui::pos2(x, y));
        }

        if points.len() > 1 {
            painter.add(egui::Shape::Path(egui::epaint::PathShape {
                points,
                closed: false,
                fill: Color32::TRANSPARENT,
                stroke: egui::Stroke::new(1.0, color),
            }));
        }
    }

    fn draw_eq_tab(&mut self, ui: &mut egui::Ui) {
        ui.vertical(|ui| {
            ui.horizontal(|ui| {
                ui.label("Equalizer");
                if ui.button("Reset").clicked() {
                    for band in &mut self.eq_bands {
                        band.gain().set_value(0.0);
                    }
                }
            });

            ui.add_space(10.0);

            ui.horizontal(|ui| {
                for (i, band) in self.eq_bands.iter_mut().enumerate() {
                    ui.vertical(|ui| {
                        ui.label(format!("{} Hz", 60 * 2_i32.pow(i as u32)));
                        let mut gain = band.gain().value();
                        if ui.add(egui::Slider::new(&mut gain, -40.0..=40.0).vertical()).changed() {
                            band.gain().set_value(gain);
                        }
                    });
                }
            });

            ui.add_space(10.0);

            ui.horizontal(|ui| {
                ui.label("Master Gain:");
                let mut master_gain = self.gain_node.gain().value();
                if ui.add(egui::Slider::new(&mut master_gain, 0.0..=2.0)).changed() {
                    self.gain_node.gain().set_value(master_gain);
                }
            });
        });
    }

    fn draw_settings_tab(&mut self, ui: &mut egui::Ui) {
        ui.heading("Theme");
        egui::ComboBox::from_label("Select a theme")
            .selected_text(format!("{:?}", self.theme))
            .show_ui(ui, |ui| {
                ui.selectable_value(&mut self.theme, Theme::Mocha, "Mocha");
                ui.selectable_value(&mut self.theme, Theme::Macchiato, "Macchiato");
                ui.selectable_value(&mut self.theme, Theme::Frappe, "Frappe");
                ui.selectable_value(&mut self.theme, Theme::Latte, "Latte");
                ui.selectable_value(&mut self.theme, Theme::Light, "Light");
                ui.selectable_value(&mut self.theme, Theme::Dark, "Dark");
            });
        ui.add_space(20.0);
        ui.label("Audio Device selection is not supported with the web-audio-api backend.");
    }

    fn open_file(&mut self, ctx: &egui::Context) {
        if let Some(handle) = rfd::FileDialog::new()
            .add_filter("Audio Files", &["mp3", "wav", "flac", "ogg", "m4a", "aac"])
            .add_filter("All Files", &["*"])
            .pick_file()
        {
            let handle = Arc::new(FileHandle::from(handle));
            self.open_file_handle(handle, ctx);
        }
    }

    fn play_pause(&mut self) {
        match self.playback_state {
            PlaybackState::Playing => {
                self.audio_context.suspend_sync();
                self.playback_state = PlaybackState::Paused;
            }
            PlaybackState::Paused => {
                self.audio_context.resume_sync();
                self.playback_state = PlaybackState::Playing;
            }
            PlaybackState::Stopped => {
                if let Some(handle) = self.current_file.clone() {
                    self.open_file_handle(handle, &egui::Context::default());
                }
            }
        }
    }

    fn stop(&mut self) {
        if let Some(source_node) = &mut self.source_node {
            source_node.stop();
            self.playback_state = PlaybackState::Stopped;
            self.playback_pos = Duration::ZERO;
        }
    }

    fn tick(&mut self) {
        // Use optimized spectrum processor for better performance
        let spectrum_data = self.spectrum_processor.process_spectrum(&self.analyser);

        // Copy the optimized spectrum data (already normalized to 0-1 range)
        self.spectrum = spectrum_data.to_vec();

        if self.playback_state == PlaybackState::Playing && !self.is_seeking {
            self.playback_pos = Duration::from_secs_f64(self.audio_context.current_time());
        }
    }

    fn handle_keyboard_input(&mut self, ui: &mut egui::Ui) {
        ui.input(|i| {
            if i.key_pressed(egui::Key::Space) {
                self.play_pause();
            }
            if i.key_pressed(egui::Key::S) {
                self.stop();
            }
            if i.key_pressed(egui::Key::L) {
                self.is_looping = !self.is_looping;
                if let Some(source_node) = &mut self.source_node {
                    source_node.set_loop(self.is_looping);
                }
            }
            if i.key_pressed(egui::Key::ArrowUp) {
                self.volume = (self.volume + 0.05).min(1.0);
                self.gain_node.gain().set_value(self.volume);
            }
            if i.key_pressed(egui::Key::ArrowDown) {
                self.volume = (self.volume - 0.05).max(0.0);
                self.gain_node.gain().set_value(self.volume);
            }
            if i.key_pressed(egui::Key::ArrowLeft) {
                if let Some(source_node) = &mut self.source_node {
                    let new_pos = self.playback_pos.saturating_sub(Duration::from_secs(5));
                    source_node.stop();
                    source_node.start_at(self.audio_context.current_time() + new_pos.as_secs_f64());
                    self.playback_pos = new_pos;
                }
            }
            if i.key_pressed(egui::Key::ArrowRight) {
                if let Some(source_node) = &mut self.source_node {
                    let new_pos = self.playback_pos.saturating_add(Duration::from_secs(5));
                    source_node.stop();
                    source_node.start_at(self.audio_context.current_time() + new_pos.as_secs_f64());
                    self.playback_pos = new_pos;
                }
            }
        });
    }

    fn open_file_handle(&mut self, handle: Arc<FileHandle>, ctx: &egui::Context) {
        let path = handle.path();
        if let Ok(tagged_file) = lofty::read_from_path(path) {
            if let Some(tag) = tagged_file.primary_tag() {
                self.metadata = Some(TrackMetadata {
                    title: tag.title().as_deref().unwrap_or("Unknown Title").into(),
                    artist: tag.artist().as_deref().unwrap_or("Unknown Artist").into(),
                    album: tag.album().as_deref().unwrap_or("Unknown Album").into(),
                    year: tag.year().map(|y| y.to_string()).unwrap_or_else(|| "----".into()),
                });
            }
            if let Some(picture) = tagged_file.primary_tag().and_then(|t| t.pictures().get(0)) {
                if let Ok(img) = image::load_from_memory(picture.data()) {
                    let (width, height) = img.dimensions();
                    let rgba = img.to_rgba8();
                    let pixels = rgba.into_raw();
                    let image = egui::ColorImage::from_rgba_unmultiplied([width as usize, height as usize], &pixels);
                    self.album_art = Some(Arc::new(ctx.load_texture("album-art", image, Default::default())));
                }
            } else {
                self.album_art = None;
            }
        }

        let file = std::fs::File::open(path).unwrap();
        let buffer = self.audio_context.decode_audio_data_sync(file).unwrap();
        self.total_duration = Duration::from_secs_f64(buffer.duration());

        let mut source_node = self.audio_context.create_buffer_source();
        source_node.set_buffer(buffer);

        source_node.connect(&self.gain_node);
        let mut previous_node: &dyn AudioNode = &self.gain_node;
        for band in &self.eq_bands {
            previous_node.connect(band);
            previous_node = band;
        }
        previous_node.connect(&self.analyser);
        self.analyser.connect(&self.audio_context.destination());

        source_node.start();
        self.source_node = Some(source_node);
        self.current_file = Some(handle.clone());
        self.playback_state = PlaybackState::Playing;
        self.playback_pos = Duration::ZERO;
        self.error = None;
    }
}

fn main() -> Result<(), eframe::Error> {
    let options = NativeOptions {
        viewport: egui::ViewportBuilder::default()
            .with_inner_size(Vec2::new(450.0, 600.0))
            .with_resizable(true),
        ..Default::default()
    };
    eframe::run_native(
        "Rusty Audio",
        options,
        Box::new(|_cc| Box::new(AudioPlayerApp::default())),
    )
}
